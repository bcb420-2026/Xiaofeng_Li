[["index.html", "worked Example Welcome", " worked Example Ruth Isserlin Welcome This mini-book introduces identifier mapping and walks through practical examples using GEO datasets: GSE233947 GSE119732 "],["what-is-identifier-mapping.html", "Chapter 1 What is identifier mapping? 1.1 Visual overview", " Chapter 1 What is identifier mapping? Identifier mapping is translating between different ways of naming the same biological entity. Common situations: Data uses stable IDs (e.g., Ensembl gene IDs) Downstream tools want gene symbols (e.g., HGNC) Some assays use non-gene identifiers (probes, peptides, genomic coordinates) 1.1 Visual overview "],["getting-data-from-geo.html", "Chapter 2 Getting data from GEO", " Chapter 2 Getting data from GEO We download GEO supplementary files to obtain realistic identifiers. library(GEOquery) ## Loading required package: Biobase ## Loading required package: BiocGenerics ## Loading required package: generics ## ## Attaching package: &#39;generics&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, ## setequal, union ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique, ## unsplit, which.max, which.min ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) source(&quot;./fetch_geo_supp.R&quot;) fetch_geo_supp(gse = &quot;GSE233947&quot;) fetch_geo_supp(gse = &quot;GSE119732&quot;) "],["why-identifiers-are-messy.html", "Chapter 3 Why identifiers are messy", " Chapter 3 Why identifiers are messy Version suffixes: Ensembl IDs can appear as ENSG... .7 and often must be stripped. One-to-many mappings: a stable ID may map to multiple symbols (aliases/synonyms). Annotation drift: mappings depend on genome build and Ensembl/HGNC releases. Best practice: keep the stable ID as the key and add symbols as annotation columns. "],["biomart-step-by-step.html", "Chapter 4 biomaRt step-by-step 4.1 1. List marts 4.2 2. (Optional) pin an Ensembl archive version 4.3 3. List datasets and select human 4.4 4. Identify the correct filter 4.5 5. Identify the correct attributes 4.6 6. Strip version suffixes (if present) 4.7 7. Run the query with getBM() 4.8 8. Cache the mapping (recommended) 4.9 9. Merge back into your data", " Chapter 4 biomaRt step-by-step This follows the following workflow: choose a mart → choose a dataset → discover filters/attributes → query with getBM() → merge back into your matrix. library(biomaRt) 4.1 1. List marts listMarts() ## biomart version ## 1 ENSEMBL_MART_ENSEMBL Ensembl Genes 115 ## 2 ENSEMBL_MART_MOUSE Mouse strains 115 ## 3 ENSEMBL_MART_SNP Ensembl Variation 115 ## 4 ENSEMBL_MART_FUNCGEN Ensembl Regulation 115 4.2 2. (Optional) pin an Ensembl archive version listEnsemblArchives()[1:10,] ## name date url version ## 1 Ensembl GRCh37 Feb 2014 https://grch37.ensembl.org GRCh37 ## 2 Ensembl 115 Sep 2025 https://sep2025.archive.ensembl.org 115 ## 3 Ensembl 114 May 2025 https://may2025.archive.ensembl.org 114 ## 4 Ensembl 113 Oct 2024 https://oct2024.archive.ensembl.org 113 ## 5 Ensembl 112 May 2024 https://may2024.archive.ensembl.org 112 ## 6 Ensembl 111 Jan 2024 https://jan2024.archive.ensembl.org 111 ## 7 Ensembl 110 Jul 2023 https://jul2023.archive.ensembl.org 110 ## 8 Ensembl 109 Feb 2023 https://feb2023.archive.ensembl.org 109 ## 9 Ensembl 108 Oct 2022 https://oct2022.archive.ensembl.org 108 ## 10 Ensembl 107 Jul 2022 https://jul2022.archive.ensembl.org 107 ## current_release ## 1 ## 2 * ## 3 ## 4 ## 5 ## 6 ## 7 ## 8 ## 9 ## 10 # Example: pin to Ensembl 114 ensembl &lt;- useEnsembl(biomart = &quot;ensembl&quot;,version = params$ensembl_version) If you do not pin versions: ensembl &lt;- useMart(&quot;ensembl&quot;) 4.3 3. List datasets and select human datasets &lt;- listDatasets(ensembl) # filter for human human &lt;- datasets[grep(datasets$dataset, pattern = &quot;hsapiens&quot;), ] human ## dataset description version ## 80 hsapiens_gene_ensembl Human genes (GRCh38.p14) GRCh38.p14 ensembl &lt;- useDataset(&quot;hsapiens_gene_ensembl&quot;, mart = ensembl) 4.4 4. Identify the correct filter Filters are your input ID type. all_filters &lt;- listFilters(ensembl) dim(all_filters) ## [1] 443 2 # search for Ensembl gene filters all_filters[grep(all_filters$name, pattern = &quot;ensembl_gene&quot;), ] ## name ## 54 ensembl_gene_id ## 55 ensembl_gene_id_version ## description ## 54 Gene stable ID(s) [e.g. ENSG00000000003] ## 55 Gene stable ID(s) with version [e.g. ENSG00000000003.17] For Ensembl gene IDs, use filter: ensembl_gene_id. 4.5 5. Identify the correct attributes Attributes are the output columns you want. all_attr &lt;- listAttributes(ensembl) all_attr[1:10,] ## name description page ## 1 ensembl_gene_id Gene stable ID feature_page ## 2 ensembl_gene_id_version Gene stable ID version feature_page ## 3 ensembl_transcript_id Transcript stable ID feature_page ## 4 ensembl_transcript_id_version Transcript stable ID version feature_page ## 5 ensembl_peptide_id Protein stable ID feature_page ## 6 ensembl_peptide_id_version Protein stable ID version feature_page ## 7 ensembl_exon_id Exon stable ID feature_page ## 8 description Gene description feature_page ## 9 chromosome_name Chromosome/scaffold name feature_page ## 10 start_position Gene start (bp) feature_page # search for HGNC searchAttributes(ensembl, &quot;hgnc&quot;) ## name description page ## 63 hgnc_symbol HGNC symbol feature_page ## 64 hgnc_id HGNC ID feature_page ## 95 hgnc_trans_name Transcript name ID feature_page Common attributes: ensembl_gene_id hgnc_symbol 4.6 6. Strip version suffixes (if present) strip_ensembl_version &lt;- function(x) sub(&quot;\\\\..*$&quot;, &quot;&quot;, x) ids &lt;- c(&quot;ENSG00000141510.17&quot;, &quot;ENSG00000157764.2&quot;) ids_clean &lt;- strip_ensembl_version(ids) ids_clean ## [1] &quot;ENSG00000141510&quot; &quot;ENSG00000157764&quot; 4.7 7. Run the query with getBM() map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ids_clean, mart = ensembl ) map ## ensembl_gene_id hgnc_symbol ## 1 ENSG00000141510 TP53 ## 2 ENSG00000157764 BRAF 4.8 8. Cache the mapping (recommended) cache_file &lt;- &quot;id_conversion.rds&quot; if (file.exists(cache_file)) { map &lt;- readRDS(cache_file) } else { map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ids_clean, mart = ensembl ) saveRDS(map, cache_file) } 4.9 9. Merge back into your data library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:biomaRt&#39;: ## ## select ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union df &lt;- tibble(ensembl_gene_id = ids_clean, value = c(1, 2)) df_annot &lt;- left_join(df, map, by = &quot;ensembl_gene_id&quot;) df_annot ## # A tibble: 2 × 3 ## ensembl_gene_id value hgnc_symbol ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 ENSG00000141510 1 TP53 ## 2 ENSG00000157764 2 BRAF "],["worked-examples-with-beforeafter-tables.html", "Chapter 5 Worked examples with before/after tables 5.1 GSE233947", " Chapter 5 Worked examples with before/after tables This chapter shows what the data look like, what the IDs look like, and how the table changes once mapped. library(knitr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tibble) kable_head &lt;- function(x, n = 5, caption = NULL) { knitr::kable(utils::head(x, n), caption = caption) } strip_ensembl_version &lt;- function(x) sub(&quot;\\\\..*$&quot;, &quot;&quot;, x) 5.1 GSE233947 5.1.1 Raw data preview source(&quot;./fetch_geo_supp.R&quot;) fetch_geo_supp(gse = params$gse) ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_FeatureCounts_V31genes_RawCounts_ENSG.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_3CTG_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_3CTG_junctions.tsv.gz path &lt;- file.path(&quot;data&quot;, params$gse) files &lt;- list.files(path, pattern = params$file_grep, full.names = TRUE, recursive = TRUE) kable_head(tibble(file = basename(files)), min(10, length(files)), paste(params$gse,&quot;: extracted file list (first 10)&quot;)) (#tab:get_data)GSE233947 : extracted file list (first 10) file GSE233947_FeatureCounts_V31genes_RawCounts_ENSG.tsv.gz GSE233947_modulize_3CTG_20CTG_junctions.tsv.gz GSE233947_modulize_NT_20CTG_junctions.tsv.gz GSE233947_modulize_NT_3CTG_junctions.tsv.gz Raw table preview library(readr) safe_read &lt;- function(file) { # First attempt: read as TSV df &lt;- tryCatch( readr::read_tsv(file, show_col_types = FALSE), error = function(e) NULL # catch fatal errors ) # If read_tsv failed entirely: if (is.null(df)) { message(&quot;TSV read failed — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If read_tsv returned but with parsing issues: probs &lt;- problems(df) if (nrow(probs) &gt; 0) { message(&quot;Parsing issues detected in TSV — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If everything was fine: return(df) } x &lt;- safe_read(files[1]) kable_head(x[, 1:min(6, ncol(x))], 5, paste(params$gse,&quot;: raw table preview&quot;)) (#tab:preview_raw)GSE233947 : raw table preview Gene T8657_900CTG_NT T8658_1150CTG_NT T8659_1450CTG_NT T8660_900CTG_20CTG T8661_1150CTG_20CTG ENSG00000108821 456397 486088 608151 2012962 379186 ENSG00000265150 170681 299425 286295 747000 210962 ENSG00000164692 169781 190854 263391 869194 180006 ENSG00000265735 78113 121697 113379 532435 112977 ENSG00000259001 55081 78811 73032 353442 100823 ID preview id_col &lt;- names(x)[1] ids &lt;- x[[1]] |&gt; as.character() kable_head(tibble(raw_id = head(ids, 10), stripped = strip_ensembl_version(head(ids, 10))), 10, paste(params$gse,&quot;: ID preview&quot;)) (#tab:id_preview)GSE233947 : ID preview raw_id stripped ENSG00000108821 ENSG00000108821 ENSG00000265150 ENSG00000265150 ENSG00000164692 ENSG00000164692 ENSG00000265735 ENSG00000265735 ENSG00000259001 ENSG00000259001 ENSG00000163359 ENSG00000163359 ENSG00000115414 ENSG00000115414 ENSG00000168542 ENSG00000168542 ENSG00000251562 ENSG00000251562 ENSG00000155657 ENSG00000155657 5.1.2 After mapping (Ensembl → HGNC) if (any(grepl(&quot;^ENSG&quot;, strip_ensembl_version(ids)))) { library(biomaRt) ensembl_ids &lt;- unique(strip_ensembl_version(ids)) ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ensembl_ids, mart = ensembl ) kable_head(map, 10, paste(params$gse,&quot;: mapping preview&quot;)) expr_mapped &lt;- x %&gt;% mutate(ensembl_gene_id = strip_ensembl_version(.data[[id_col]])) %&gt;% left_join(map, by = &quot;ensembl_gene_id&quot;) %&gt;% dplyr::select( ensembl_gene_id,hgnc_symbol, everything()) kable_head(expr_mapped[, 1:min(8, ncol(expr_mapped))], 5, paste(params$gse,&quot;: mapped table preview&quot;)) } (#tab:after_map)GSE233947 : mapped table preview ensembl_gene_id hgnc_symbol Gene T8657_900CTG_NT T8658_1150CTG_NT T8659_1450CTG_NT T8660_900CTG_20CTG T8661_1150CTG_20CTG ENSG00000108821 COL1A1 ENSG00000108821 456397 486088 608151 2012962 379186 ENSG00000265150 NA ENSG00000265150 170681 299425 286295 747000 210962 ENSG00000164692 COL1A2 ENSG00000164692 169781 190854 263391 869194 180006 ENSG00000265735 RN7SL5P ENSG00000265735 78113 121697 113379 532435 112977 ENSG00000259001 ENSG00000259001 55081 78811 73032 353442 100823 Summarize the mapping n_ensembl_total &lt;- expr_mapped %&gt;% distinct(ensembl_gene_id) %&gt;% nrow() n_mapped &lt;- expr_mapped %&gt;% filter(!is.na(hgnc_symbol), hgnc_symbol != &quot;&quot;) %&gt;% distinct(ensembl_gene_id) %&gt;% nrow() n_unmapped &lt;- n_ensembl_total - n_mapped mapping_summary &lt;- tibble::tibble( category = c(&quot;Total Ensembl IDs&quot;, &quot;Mapped to HGNC&quot;, &quot;Unmapped&quot;), n = c(n_ensembl_total, n_mapped, n_unmapped) ) mapping_summary ## # A tibble: 3 × 2 ## category n ## &lt;chr&gt; &lt;int&gt; ## 1 Total Ensembl IDs 62248 ## 2 Mapped to HGNC 40176 ## 3 Unmapped 22072 unmapped_ids &lt;- expr_mapped %&gt;% distinct(ensembl_gene_id, hgnc_symbol) %&gt;% filter(is.na(hgnc_symbol) | hgnc_symbol == &quot;&quot;) %&gt;% pull(ensembl_gene_id) %&gt;% unique() length(unmapped_ids) ## [1] 22072 library(stringr) unmapped_classified &lt;- tibble::tibble(id = unmapped_ids) %&gt;% mutate(type = case_when( str_detect(id, &quot;^ENSG\\\\d+$&quot;) ~ &quot;Ensembl gene ID (ENSG)&quot;, str_detect(id, &quot;^ENSG\\\\d+\\\\.\\\\d+$&quot;) ~ &quot;Ensembl gene ID with version (ENSG.x) — needs stripping&quot;, str_detect(id, &quot;^ENST\\\\d+&quot;) ~ &quot;Ensembl transcript ID (ENST) — wrong target for gene mapping&quot;, str_detect(id, &quot;^ENSP\\\\d+&quot;) ~ &quot;Ensembl protein ID (ENSP) — wrong target&quot;, str_detect(id, &quot;^ENS.*G\\\\d+&quot;) ~ &quot;Non-human Ensembl gene (e.g., ENSMUSG...) — wrong organism&quot;, str_detect(id, &quot;^ERCC-&quot;) ~ &quot;ERCC spike-in control — not a gene&quot;, str_detect(id, &quot;^MT-|^mt-&quot;) ~ &quot;Mitochondrial gene symbol (not Ensembl ID) — different ID system&quot;, str_detect(id, &quot;^\\\\d+$&quot;) ~ &quot;Entrez Gene ID — different ID system&quot;, TRUE ~ &quot;Other / unknown format&quot; )) unmapped_classified %&gt;% count(type) %&gt;% arrange(desc(n)) ## # A tibble: 1 × 2 ## type n ## &lt;chr&gt; &lt;int&gt; ## 1 Ensembl gene ID (ENSG) 22072 # Use the same mart/dataset as your mapping step: # ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) ensg_details &lt;- getBM( attributes = c( &quot;ensembl_gene_id&quot;, &quot;gene_biotype&quot;, &quot;external_gene_name&quot; ), filters = &quot;ensembl_gene_id&quot;, values = unmapped_ids, mart = ensembl ) head(ensg_details) ## ensembl_gene_id gene_biotype external_gene_name ## 1 ENSG00000093100 lncRNA ## 2 ENSG00000124593 protein_coding ## 3 ENSG00000124835 lncRNA ## 4 ENSG00000141979 protein_coding ## 5 ENSG00000149656 transcribed_unprocessed_pseudogene ## 6 ENSG00000151303 lncRNA Output the distribution of biotypes for the subset of ensembl ids that have no HGNC ID. library(ggplot2) x &lt;- ensg_details$gene_biotype x[is.na(x)] &lt;- &quot;Unknown&quot; # Base R counts table -&gt; data.frame tab &lt;- table(x) df_counts &lt;- data.frame( biotype = names(tab), n = as.integer(tab), stringsAsFactors = FALSE ) # Order by counts (ascending) for a nice horizontal bar chart df_counts &lt;- df_counts[order(df_counts$n,decreasing = TRUE), ] df_counts$biotype &lt;- factor(df_counts$biotype, levels = df_counts$biotype) #only include the top 20 biotypes df_counts &lt;- df_counts[1:min(10, nrow(df_counts)), ] ggplot(df_counts, aes(x = biotype, y = n, fill = biotype)) + geom_col(width = 0.8, color = &quot;grey20&quot;) + coord_flip() + scale_fill_brewer(palette = &quot;Set3&quot;, guide = &quot;none&quot;) + labs( x = NULL, y = &quot;Number of genes&quot;, title = &quot;Distribution of Gene Biotypes - \\ntop 10 types not mapped&quot; ) + theme_minimal(base_size = 13) + theme( plot.title.position = &quot;plot&quot;, panel.grid.major.y = element_blank() ) Would the mapping of these identifiers have been different if we used a different version of Ensembl? "],["exercises.html", "Chapter 6 Exercises 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 6.3 Exercise 3 -", " Chapter 6 Exercises These are intended to be done after completing the worked examples. 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 Using GSE119732, confirm whether the ID column contains Ensembl IDs with version suffixes. Extract the first 20 IDs. Count how many contain a .. Create a new column with versions stripped. Map the identifiers to HGNC symbols. 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 Using GSE122380, confirm whether the ID column contains Ensembl IDs with version suffixes. Extract the first 20 IDs. Create a new column with versions stripped. Map the identifiers to HGNC symbols. What is different about this file? 6.3 Exercise 3 - Can you use the worked example to process the above two GEO records? How? "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
